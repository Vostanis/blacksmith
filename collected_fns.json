[{"fn_name":"get_vec","item_str":"pub async fn get_vec(urls : Vec < & str >, save_path : & str, threads : usize)\n{\n    let client = reqwest :: Client :: new() ; futures :: stream ::\n    iter(urls.into_iter().map(| url |\n    {\n        let future = client.get(url).send() ; async move\n        {\n            match future.await\n            {\n                Ok(resp) =>\n                {\n                    match resp.bytes().await\n                    {\n                        Ok(bytes) =>\n                        { download_url_file(url, bytes, save_path).await ; }, Err(_)\n                        => eprintln! (\"[ERROR]   Failed to retrieve bytes: {url}\"),\n                    }\n                }, Err(_) => eprintln!\n                (\"[ERROR]   Failed to return response: {url}\"),\n            }\n        }\n    })).buffer_unordered(threads).collect :: < Vec < () >> ().await ;\n}"},{"fn_name":"download_url_file","item_str":"pub async fn\ndownload_url_file(url : & str, bytes : bytes :: Bytes, save_path : & str)\n{\n    if let Some(file) = std :: path :: Path :: new(& url).file_name()\n    {\n        let file_path = std :: path :: Path :: new(save_path).join(file) ; let\n        _ = tokio :: fs :: write(& file_path, bytes).await ; println!\n        (\"[SUCCESS] File written {file_path:?}\") ;\n    } else { eprintln! (\"[ERROR]   File name unreadable: {url}\") }\n}"}]